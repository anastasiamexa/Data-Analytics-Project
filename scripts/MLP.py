# -*- coding: utf-8 -*-
"""MLP.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YWXN5sCSMIFt3nwtCNQcPXUFoMo8LxPM
"""

import pandas as pd
import numpy as np
from sklearn.preprocessing import LabelEncoder
from sklearn.utils import shuffle
import tensorflow as tf
from keras.utils import np_utils
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import Dropout
import matplotlib.pyplot as plt
from sklearn.metrics import matthews_corrcoef
from sklearn.metrics import confusion_matrix

X = pd.read_excel('CTG(1).xlsx',usecols = "A:U")  # loading the input data
Y = pd.read_excel('CTG(1).xlsx',usecols = "V")  # loading the output data
input = X[1:].values
output = Y[1:].values

# Converting the output data using the one hot vector encoding
output_en = np_utils.to_categorical(output)

# Examples of conversion
print(output[:5])
print(output_en[:5, :])

# Split data into train and test
len_data = input.shape[0]
print(len_data)
train_size = int(len_data * .6)
valid_size = int(len_data * .1)
print ("Train size (60 %): ", train_size)
print ("Validation size (10 %): ", valid_size)
print ("Test size (30 %): ", (len_data - (train_size+valid_size)))

xtr = input[:train_size,:]
ytr = output_en[:train_size,:]
ytr_bool = output[:train_size]

xva = input[train_size:train_size+valid_size,:]
yva = output_en[train_size:train_size+valid_size,:]
yva_bool = output[train_size:train_size+valid_size]

xte = input[train_size+valid_size:,:]
yte = output_en[train_size+valid_size:,:]
yte_bool = output[train_size+valid_size:]

# Define model
model = Sequential()
model.add(Dense(25, input_shape = (21,), activation='relu'))
model.add(Dense(25, activation='relu'))
#model.add(Dropout(0.5))
model.add(Dense(11, activation='softmax'))

# Compile model
model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])

print(model.summary())

from keras.utils.vis_utils import plot_model
plot_model(model, to_file='model.png')

# Fit model
history = model.fit(tf.convert_to_tensor(xtr, dtype=tf.float32), \
                    ytr, validation_data=(tf.convert_to_tensor(xva, dtype=tf.float32), yva), epochs=30, batch_size=1, verbose=2)

# Plot training and validation loss
plt.figure(figsize=(20, 10))
plt.subplot(2, 1, 1)
plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.subplot(2, 1, 2)
plt.plot(history.history['accuracy'])
plt.plot(history.history['val_accuracy'])
plt.show()

# Evaluate and Predict
scores = model.evaluate(tf.convert_to_tensor(xtr, dtype=tf.float32), ytr, verbose=0)
print("Train %s: %.2f%%" % (model.metrics_names[1], scores[1]*100))

ytr_pred = model.predict_classes(tf.convert_to_tensor(xtr, dtype=tf.float32), verbose=0)
print("Train Accuracy by model.predict: %.2f%%" % (100*sum(ytr_bool.flatten() == ytr_pred)/ytr.shape[0]))

# make class predictions with the model
yva_pred = model.predict_classes(tf.convert_to_tensor(xva, dtype=tf.float32), verbose=0)
print("Val Accuracy by model.predict: %.2f%%" % (100*sum(yva_bool.flatten() == yva_pred)/yva.shape[0]))

# make class predictions with the model
yte_pred = model.predict(tf.convert_to_tensor(xte, dtype=tf.float32), batch_size=1, verbose=0)
yte_pred_bool = np.argmax(yte_pred, axis=1)
print("Test Accuracy by model.predict: %.2f%%" % (100*sum(yte_bool.flatten() == yte_pred_bool)/yte.shape[0]))

print("---------------TRAIN---------------------")
print(confusion_matrix(ytr_bool.flatten().tolist(), ytr_pred.tolist()))
print("---------------VAL---------------------")
print(confusion_matrix(yva_bool.flatten().tolist(), yva_pred.tolist()))
print("---------------TEST---------------------")
print(confusion_matrix(yte_bool.flatten().tolist(), yte_pred_bool.tolist()))